<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[快速幂]]></title>
      <url>/2022/10/18/NO7/</url>
      <content type="html"><![CDATA[<h1 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h1><h2 id="🚀介绍"><a href="#🚀介绍" class="headerlink" title="🚀介绍"></a>🚀介绍</h2><blockquote>
<p>快速幂指的是在不进行调用语言外部函数的情况下，自己完成幂运算，一般的幂运算在碰到数据量比较大时，会出现时间复杂度过高的情况，因为乘法是很耗费运算时间的。所以有了快速幂的算法。快速幂可用于多种幂运算的场景。帮助降低时间复杂度。</p>
<p>快速幂有两种常见的算法，一种是递归法，一种是迭代法。</p>
</blockquote>
<h1 id="🎯递归法"><a href="#🎯递归法" class="headerlink" title="🎯递归法"></a>🎯递归法</h1><blockquote>
<p><strong>pow(m,n),表示的是m的n次方。</strong></p>
<p>先看几个例子：</p>
<blockquote>
<p>令n=64</p>
<p>​       m-&gt;m^2^ -&gt;m^4^ -&gt;m^8^-&gt;m^16^ -&gt;m^32^ -&gt;m^64^ </p>
</blockquote>
<blockquote>
<p>令n = 12 </p>
<p>​       m-&gt;m^3^-&gt;m^6^ -&gt;m^12^</p>
</blockquote>
<blockquote>
<p>令n = 13</p>
<p>​       m-&gt;m^3^-&gt;m^6^ -&gt;m^13^</p>
</blockquote>
<p>着重从右向左看上标的变化，若是奇数 13 就是需要6+6+1，偶数12直接就是6+6，直接就是除2向下取整得到需要递归的数，然后再判断奇数偶数来判断是否需要再乘以m。</p>
<p>整个流程如下：</p>
<ul>
<li>pow(m,n)</li>
<li>判断n是否为0，为0递归结束返回1</li>
<li>不为0，x = $\lfloor{n}\rfloor$</li>
<li>计算y=pow(m,x)</li>
<li>返回 y*y *（偶数为1，奇数为m）</li>
</ul>
</blockquote>
<p>⏯java代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">myPow</span><span class="params">(<span class="type">double</span> x, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">N</span> <span class="operator">=</span> n;</span><br><span class="line">        <span class="comment">//记得考虑负数的计算法则</span></span><br><span class="line">        <span class="keyword">return</span> N &gt;= <span class="number">0</span> ? quickMul(x, N) : <span class="number">1.0</span> / quickMul(x, -N);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">quickMul</span><span class="params">(<span class="type">double</span> x, <span class="type">long</span> N)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (N == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">double</span> <span class="variable">y</span> <span class="operator">=</span> quickMul(x, N / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> N % <span class="number">2</span> == <span class="number">0</span> ? y * y : y * y * x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h1 id="🤡迭代法"><a href="#🤡迭代法" class="headerlink" title="🤡迭代法"></a>🤡迭代法</h1><blockquote>
<p>迭代法就更加厉害了，是对于规律的深层次把握。</p>
<p><em>x</em>→<em>x</em>2→<em>x</em>4→+<em>x</em>9→+x<em>19→</em>+x*38→+*x77</p>
<p>上面的77次方是怎么来的呢，首先77/2，余数为1，也就是二进制右移出来的一位，对最终的结果贡献为m^1^</p>
<p>同理，19/2，余数为1，相当于77二进制移出来3位，对最终的结果都贡献为m^4^<br>           9/2,余数为1，贡献为m^8^<br>         最后x 贡献为 m^64^</p>
</blockquote>
<blockquote>
<p> m^1^  * m^8^  * m^64^  = m^77^   而77的二进制位 <strong>1001101</strong>   ，对应每一个1.</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">myPow</span><span class="params">(<span class="type">double</span> x, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">N</span> <span class="operator">=</span> n;</span><br><span class="line">        <span class="keyword">return</span> N &gt;= <span class="number">0</span> ? quickMul(x, N) : <span class="number">1.0</span> / quickMul(x, -N);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">quickMul</span><span class="params">(<span class="type">double</span> x, <span class="type">long</span> N)</span> &#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">1.0</span>;</span><br><span class="line">        <span class="comment">// 贡献的初始值为 x</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">x_contribute</span> <span class="operator">=</span> x;</span><br><span class="line">        <span class="comment">// 在对 N 进行二进制拆分的同时计算答案</span></span><br><span class="line">        <span class="keyword">while</span> (N &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (N % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果 N 二进制表示的最低位为 1，那么需要计入贡献</span></span><br><span class="line">                ans *= x_contribute;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将贡献不断地平方</span></span><br><span class="line">            x_contribute *= x_contribute;</span><br><span class="line">            <span class="comment">// 舍弃 N 二进制表示的最低位，这样我们每次只要判断最低位即可</span></span><br><span class="line">            N /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      
        <categories>
            
            <category> 算法集锦 </category>
            
            <category> 算法题 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 快速幂 </tag>
            
            <tag> 递归 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[数位DP模板]]></title>
      <url>/2022/10/18/NO6/</url>
      <content type="html"><![CDATA[<h1 id="数位DP"><a href="#数位DP" class="headerlink" title="数位DP"></a>数位DP</h1><blockquote>
<p>数位dp的题型都有很明显的特征，通常就是给定一个值100、1425、36479、。。。。。然后给定一个规则，求满足规则的小于等于给定值的数量</p>
</blockquote>
<p><strong>模板</strong></p>
<blockquote>
<h4 id="169、最大为-N-的数字组合"><a href="#169、最大为-N-的数字组合" class="headerlink" title="169、最大为 N 的数字组合"></a><a href="https://leetcode.cn/problems/numbers-at-most-n-given-digit-set/">169、最大为 N 的数字组合</a></h4><p>难度困难</p>
<p>给定一个按 <strong>非递减顺序</strong> 排列的数字数组 <code>digits</code> 。你可以用任意次数 <code>digits[i]</code> 来写的数字。例如，如果 <code>digits = [&#39;1&#39;,&#39;3&#39;,&#39;5&#39;]</code>，我们可以写数字，如 <code>&#39;13&#39;</code>, <code>&#39;551&#39;</code>, 和 <code>&#39;1351315&#39;</code>。</p>
<p>返回 <em>可以生成的小于或等于给定整数 <code>n</code> 的正整数的个数</em> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：digits = [&quot;1&quot;,&quot;3&quot;,&quot;5&quot;,&quot;7&quot;], n = 100</span><br><span class="line">输出：20</span><br><span class="line">解释：</span><br><span class="line">可写出的 20 个数字是：</span><br><span class="line">1, 3, 5, 7, 11, 13, 15, 17, 31, 33, 35, 37, 51, 53, 55, 57, 71, 73, 75, 77.</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：digits = [&quot;1&quot;,&quot;4&quot;,&quot;9&quot;], n = 1000000000</span><br><span class="line">输出：29523</span><br><span class="line">解释：</span><br><span class="line">我们可以写 3 个一位数字，9 个两位数字，27 个三位数字，</span><br><span class="line">81 个四位数字，243 个五位数字，729 个六位数字，</span><br><span class="line">2187 个七位数字，6561 个八位数字和 19683 个九位数字。</span><br><span class="line">总共，可以使用D中的数字写出 29523 个整数。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：digits = [&quot;7&quot;], n = 8</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><p><code>1 &lt;= digits.length &lt;= 9</code></p>
</li>
<li><p><code>digits[i].length == 1</code></p>
</li>
<li><p><code>digits[i]</code> 是从 <code>&#39;1&#39;</code> 到 <code>&#39;9&#39;</code> 的数</p>
</li>
<li><p><code>digits</code> 中的所有值都 <strong>不同</strong> </p>
</li>
<li><p><code>digits</code> 按 <strong>非递减顺序</strong> 排列</p>
</li>
<li><p><code>1 &lt;= n &lt;= 109</code></p>
</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">atMostNGivenDigitSet</span><span class="params">(String[] D, <span class="type">int</span> N)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">S</span> <span class="operator">=</span> String.valueOf(N);</span><br><span class="line">        <span class="type">int</span> <span class="variable">K</span> <span class="operator">=</span> S.length();</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[K+<span class="number">1</span>];</span><br><span class="line">        dp[K] = <span class="number">1</span>;<span class="comment">//这个代表N自身，先给加上避免忘了</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//下面就是dp的过程，例如给定6542，下面循环就是求1*** ，2***,3***,4***,5***,61**....65**,654*..,6542,其实这里缺少一些数字，三位数，两位数，不要急，再下面</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> K-<span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="comment">// compute dp[i]</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">Si</span> <span class="operator">=</span> S.charAt(i) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">for</span> (String d: D) &#123;</span><br><span class="line">                <span class="keyword">if</span> (Integer.valueOf(d) &lt; Si)</span><br><span class="line">                    dp[i] += Math.pow(D.length, K-i-<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (Integer.valueOf(d) == Si)</span><br><span class="line">                    dp[i] += dp[i+<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//这里就是三位数，两位数的。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; K; ++i)</span><br><span class="line">            dp[<span class="number">0</span>] += Math.pow(D.length, i);</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      
        <categories>
            
            <category> 算法集锦 </category>
            
            <category> 算法模板 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 模板 </tag>
            
            <tag> 数位dp </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[并查集]]></title>
      <url>/2022/10/18/NO5/</url>
      <content type="html"><![CDATA[<h1 id="1-并查集代码"><a href="#1-并查集代码" class="headerlink" title="1.并查集代码"></a>1.并查集代码</h1><p><a href="https://www.runoob.com/data-structures/union-find-basic.html">具体原理</a></p>
<h2 id="1-1-简单代码"><a href="#1-1-简单代码" class="headerlink" title="1.1 简单代码"></a>1.1 简单代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UnionFind2</span> &#123;</span><br><span class="line">    <span class="comment">// 我们的第二版Union-Find, 使用一个数组构建一棵指向父节点的树</span></span><br><span class="line">    <span class="comment">// parent[i]表示第一个元素所指向的父节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] parent;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> count;  <span class="comment">// 数据个数</span></span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UnionFind2</span><span class="params">(<span class="type">int</span> count)</span>&#123;</span><br><span class="line">        parent = <span class="keyword">new</span> <span class="title class_">int</span>[count];</span><br><span class="line">        <span class="built_in">this</span>.count = count;</span><br><span class="line">        <span class="comment">// 初始化, 每一个parent[i]指向自己, 表示每一个元素自己自成一个集合</span></span><br><span class="line">        <span class="keyword">for</span>( <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; count ; i ++ )</span><br><span class="line">            parent[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 查找过程, 查找元素p所对应的集合编号</span></span><br><span class="line">    <span class="comment">// O(h)复杂度, h为树的高度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> p)</span>&#123;</span><br><span class="line">        <span class="keyword">assert</span>( p &gt;= <span class="number">0</span> &amp;&amp; p &lt; count );</span><br><span class="line">        <span class="comment">// 不断去查询自己的父亲节点, 直到到达根节点</span></span><br><span class="line">        <span class="comment">// 根节点的特点: parent[p] == p</span></span><br><span class="line">        <span class="keyword">while</span>( p != parent[p] )</span><br><span class="line">            p = parent[p];</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 查看元素p和元素q是否所属一个集合</span></span><br><span class="line">    <span class="comment">// O(h)复杂度, h为树的高度</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isConnected</span><span class="params">( <span class="type">int</span> p , <span class="type">int</span> q )</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> find(p) == find(q);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 合并元素p和元素q所属的集合</span></span><br><span class="line">    <span class="comment">// O(h)复杂度, h为树的高度</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unionElements</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pRoot</span> <span class="operator">=</span> find(p);</span><br><span class="line">        <span class="type">int</span> <span class="variable">qRoot</span> <span class="operator">=</span> find(q);</span><br><span class="line">        <span class="keyword">if</span>( pRoot == qRoot )</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        parent[pRoot] = qRoot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="1-2-size-优化代码"><a href="#1-2-size-优化代码" class="headerlink" title="1.2 size 优化代码"></a>1.2 size 优化代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UnionFind3</span> &#123;</span><br><span class="line">    <span class="comment">// parent[i]表示第一个元素所指向的父节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] parent;</span><br><span class="line">    <span class="comment">// sz[i]表示以i为根的集合中元素个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] sz;</span><br><span class="line">    <span class="comment">// 数据个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UnionFind3</span><span class="params">(<span class="type">int</span> count)</span>&#123;</span><br><span class="line">        parent = <span class="keyword">new</span> <span class="title class_">int</span>[count];</span><br><span class="line">        sz = <span class="keyword">new</span> <span class="title class_">int</span>[count];</span><br><span class="line">        <span class="built_in">this</span>.count = count;</span><br><span class="line">        <span class="comment">// 初始化, 每一个parent[i]指向自己, 表示每一个元素自己自成一个集合</span></span><br><span class="line">        <span class="keyword">for</span>( <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; count ; i ++ )&#123;</span><br><span class="line">            parent[i] = i;</span><br><span class="line">            sz[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找过程, 查找元素p所对应的集合编号</span></span><br><span class="line">    <span class="comment">// O(h)复杂度, h为树的高度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> p)</span>&#123;</span><br><span class="line">        <span class="keyword">assert</span>( p &gt;= <span class="number">0</span> &amp;&amp; p &lt; count );</span><br><span class="line">        <span class="comment">// 不断去查询自己的父亲节点, 直到到达根节点</span></span><br><span class="line">        <span class="comment">// 根节点的特点: parent[p] == p</span></span><br><span class="line">        <span class="keyword">while</span>( p != parent[p] )</span><br><span class="line">            p = parent[p];</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查看元素p和元素q是否所属一个集合</span></span><br><span class="line">    <span class="comment">// O(h)复杂度, h为树的高度</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isConnected</span><span class="params">( <span class="type">int</span> p , <span class="type">int</span> q )</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> find(p) == find(q);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 合并元素p和元素q所属的集合</span></span><br><span class="line">    <span class="comment">// O(h)复杂度, h为树的高度</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unionElements</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pRoot</span> <span class="operator">=</span> find(p);</span><br><span class="line">        <span class="type">int</span> <span class="variable">qRoot</span> <span class="operator">=</span> find(q);</span><br><span class="line">        <span class="keyword">if</span>( pRoot == qRoot )</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 根据两个元素所在树的元素个数不同判断合并方向</span></span><br><span class="line">        <span class="comment">// 将元素个数少的集合合并到元素个数多的集合上</span></span><br><span class="line">        <span class="keyword">if</span>( sz[pRoot] &lt; sz[qRoot] )&#123;</span><br><span class="line">            parent[pRoot] = qRoot;</span><br><span class="line">            sz[qRoot] += sz[pRoot];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            parent[qRoot] = pRoot;</span><br><span class="line">            sz[pRoot] += sz[qRoot];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="1-3-rank优化代码"><a href="#1-3-rank优化代码" class="headerlink" title="1.3 rank优化代码"></a>1.3 rank优化代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 基于rank的优化</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UnionFind4</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] rank;   <span class="comment">// rank[i]表示以i为根的集合所表示的树的层数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] parent; <span class="comment">// parent[i]表示第i个元素所指向的父节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> count;    <span class="comment">// 数据个数</span></span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UnionFind4</span><span class="params">(<span class="type">int</span> count)</span>&#123;</span><br><span class="line">        rank = <span class="keyword">new</span> <span class="title class_">int</span>[count];</span><br><span class="line">        parent = <span class="keyword">new</span> <span class="title class_">int</span>[count];</span><br><span class="line">        <span class="built_in">this</span>.count = count;</span><br><span class="line">        <span class="comment">// 初始化, 每一个parent[i]指向自己, 表示每一个元素自己自成一个集合</span></span><br><span class="line">        <span class="keyword">for</span>( <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; count ; i ++ )&#123;</span><br><span class="line">            parent[i] = i;</span><br><span class="line">            rank[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 查找过程, 查找元素p所对应的集合编号</span></span><br><span class="line">    <span class="comment">// O(h)复杂度, h为树的高度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> p)</span>&#123;</span><br><span class="line">        <span class="keyword">assert</span>( p &gt;= <span class="number">0</span> &amp;&amp; p &lt; count );</span><br><span class="line">        <span class="comment">// 不断去查询自己的父亲节点, 直到到达根节点</span></span><br><span class="line">        <span class="comment">// 根节点的特点: parent[p] == p</span></span><br><span class="line">        <span class="keyword">while</span>( p != parent[p] )</span><br><span class="line">            p = parent[p];</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 查看元素p和元素q是否所属一个集合</span></span><br><span class="line">    <span class="comment">// O(h)复杂度, h为树的高度</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isConnected</span><span class="params">( <span class="type">int</span> p , <span class="type">int</span> q )</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> find(p) == find(q);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 合并元素p和元素q所属的集合</span></span><br><span class="line">    <span class="comment">// O(h)复杂度, h为树的高度</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unionElements</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pRoot</span> <span class="operator">=</span> find(p);</span><br><span class="line">        <span class="type">int</span> <span class="variable">qRoot</span> <span class="operator">=</span> find(q);</span><br><span class="line">        <span class="keyword">if</span>( pRoot == qRoot )</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>( rank[pRoot] &lt; rank[qRoot] )&#123;</span><br><span class="line">            parent[pRoot] = qRoot;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>( rank[qRoot] &lt; rank[pRoot])&#123;</span><br><span class="line">            parent[qRoot] = pRoot;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123; <span class="comment">// rank[pRoot] == rank[qRoot]</span></span><br><span class="line">            parent[pRoot] = qRoot;</span><br><span class="line">            rank[qRoot] += <span class="number">1</span>;   <span class="comment">// 维护rank的值</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="1-4-路径优化代码"><a href="#1-4-路径优化代码" class="headerlink" title="1.4 路径优化代码"></a>1.4 路径优化代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UnionFind4</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] rank;   <span class="comment">// rank[i]表示以i为根的集合所表示的树的层数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] parent; <span class="comment">// parent[i]表示第i个元素所指向的父节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> count;    <span class="comment">// 数据个数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UnionFind4</span><span class="params">(<span class="type">int</span> count)</span>&#123;</span><br><span class="line">        rank = <span class="keyword">new</span> <span class="title class_">int</span>[count];</span><br><span class="line">        parent = <span class="keyword">new</span> <span class="title class_">int</span>[count];</span><br><span class="line">        <span class="built_in">this</span>.count = count;</span><br><span class="line">        <span class="comment">// 初始化, 每一个parent[i]指向自己, 表示每一个元素自己自成一个集合</span></span><br><span class="line">        <span class="keyword">for</span>( <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; count ; i ++ )&#123;</span><br><span class="line">            parent[i] = i;</span><br><span class="line">            rank[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找过程, 查找元素p所对应的集合编号</span></span><br><span class="line">    <span class="comment">// O(h)复杂度, h为树的高度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> p)</span>&#123;</span><br><span class="line">        <span class="keyword">assert</span>( p &gt;= <span class="number">0</span> &amp;&amp; p &lt; count );</span><br><span class="line">        <span class="comment">// 不断去查询自己的父亲节点, 直到到达根节点</span></span><br><span class="line">        <span class="comment">// 根节点的特点: parent[p] == p</span></span><br><span class="line">        <span class="keyword">while</span>( p != parent[p] )</span><br><span class="line">            p = parent[p];</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第二种路径压缩算法</span></span><br><span class="line">        <span class="comment">//if( p != parent[p] )</span></span><br><span class="line">        <span class="comment">//parent[p] = find( parent[p] );</span></span><br><span class="line">        <span class="comment">//return parent[p];</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查看元素p和元素q是否所属一个集合</span></span><br><span class="line">    <span class="comment">// O(h)复杂度, h为树的高度</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isConnected</span><span class="params">( <span class="type">int</span> p , <span class="type">int</span> q )</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> find(p) == find(q);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 合并元素p和元素q所属的集合</span></span><br><span class="line">    <span class="comment">// O(h)复杂度, h为树的高度</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unionElements</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">pRoot</span> <span class="operator">=</span> find(p);</span><br><span class="line">        <span class="type">int</span> <span class="variable">qRoot</span> <span class="operator">=</span> find(q);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( pRoot == qRoot )</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( rank[pRoot] &lt; rank[qRoot] )&#123;</span><br><span class="line">            parent[pRoot] = qRoot;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>( rank[qRoot] &lt; rank[pRoot])&#123;</span><br><span class="line">            parent[qRoot] = pRoot;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123; <span class="comment">// rank[pRoot] == rank[qRoot]</span></span><br><span class="line">            parent[pRoot] = qRoot;</span><br><span class="line">            rank[qRoot] += <span class="number">1</span>;   <span class="comment">// 维护rank的值</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      
        <categories>
            
            <category> 算法集锦 </category>
            
            <category> 算法模板 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 模板 </tag>
            
            <tag> 并查集 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[二分图模板]]></title>
      <url>/2022/10/18/NO4/</url>
      <content type="html"><![CDATA[<h1 id="1-染色法判定二分图模板"><a href="#1-染色法判定二分图模板" class="headerlink" title="1.染色法判定二分图模板"></a>1.染色法判定二分图模板</h1><blockquote>
<p>染色法模板一般用于判定二分图，何为二分图？直白的将就是一个图，将图中相互连接的两个 节点之间分成两份，或者说两个节点之间必须是属于两个不同的集合</p>
<p>这样的模板题通常的思路就是模拟，但不是普通的模拟，要先利用图的存储原理——前向星链表存储，然后再进行DFS，所以想要理解这个模板，必须要先学会前向星链表存储</p>
</blockquote>
<h1 id="2-前向星链图表示法"><a href="#2-前向星链图表示法" class="headerlink" title="2.前向星链图表示法"></a>2.前向星链图表示法</h1><blockquote>
<p>首先原理就是对于图里的节点都要用序号表示，然后我们用这个序号和数组index给重合，这样是不是就可以对边存储一些附加属性，然后再将节点也给这样使用。具体看下面的代码</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//he 就是节点数组，每一个he的index表示一个节点序号，数组值代表节点属性，这里的属性表示这个节点作为头节点第一个出边的序号。</span></span><br><span class="line"><span class="comment">//e 就是第一个边数组，e的index表示边序号，数组值表示边的属性，这里规定属性是这个边指向的节点的序号</span></span><br><span class="line"><span class="comment">//ne 就是第二个边数组，ne的index表示边序号，数组值表示边的属性，这里规定这个属性是和这个边共同头节点的邻居边的序号。</span></span><br><span class="line"><span class="comment">//wi 是第三个，这里的属性是边的权重</span></span><br><span class="line"><span class="type">int</span>[] he = <span class="keyword">new</span> <span class="title class_">int</span>[N], e = <span class="keyword">new</span> <span class="title class_">int</span>[M], ne = <span class="keyword">new</span> <span class="title class_">int</span>[M], w = <span class="keyword">new</span> <span class="title class_">int</span>[M];</span><br><span class="line"><span class="type">int</span> idx;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span> &#123;</span><br><span class="line">    e[idx] = b;</span><br><span class="line">    ne[idx] = he[a];</span><br><span class="line">    he[a] = idx;</span><br><span class="line">    w[idx] = c;</span><br><span class="line">    idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//建立好模型之后，最重要的是如何遍历</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> he[a]; i != -<span class="number">1</span>; i = ne[i]) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> e[i], c = w[i]; <span class="comment">// 存在由 a 指向 b 的边，权重为 c</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="3-以题代练"><a href="#3-以题代练" class="headerlink" title="3.以题代练"></a>3.以题代练</h1><blockquote>
<h4 id="886-可能的二分法"><a href="#886-可能的二分法" class="headerlink" title="886. 可能的二分法"></a><a href="https://leetcode.cn/problems/possible-bipartition/">886. 可能的二分法</a></h4><p>难度中等</p>
<p>给定一组 <code>n</code> 人（编号为 <code>1, 2, ..., n</code>）， 我们想把每个人分进<strong>任意</strong>大小的两组。每个人都可能不喜欢其他人，那么他们不应该属于同一组。</p>
<p>给定整数 <code>n</code> 和数组 <code>dislikes</code> ，其中 <code>dislikes[i] = [ai, bi]</code> ，表示不允许将编号为 <code>ai</code> 和 <code>bi</code>的人归入同一组。当可以用这种方法将所有人分进两组时，返回 <code>true</code>；否则返回 <code>false</code>。</p>
</blockquote>
<p>示例 1：</p>
<blockquote>
<p>输入：n = 4, dislikes = [[1,2],[1,3],[2,4]]<br>     输出：true<br>        解释：group1 [1,4], group2 [2,3]</p>
<p>示例 2：</p>
<p>输入：n = 3, dislikes = [[1,2],[1,3],[2,3]]<br>        输出：false<br>     示例 3：</p>
<p>输入：n = 5, dislikes = [[1,2],[2,3],[3,4],[4,5],[1,5]]<br>      输出：false</p>
</blockquote>
<blockquote>
<blockquote>
<p>提示： </p>
<p>1 &lt;= n &lt;= 2000<br>0 &lt;= dislikes.length &lt;= 104<br>dislikes[i].length == 2<br>1 &lt;= dislikes[i][j] &lt;= n<br>ai &lt; bi<br>dislikes 中每一组都 不同</p>
</blockquote>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> <span class="number">2010</span>, M = <span class="number">2</span> * <span class="number">10010</span>;</span><br><span class="line">    <span class="type">int</span>[] he = <span class="keyword">new</span> <span class="title class_">int</span>[N], e = <span class="keyword">new</span> <span class="title class_">int</span>[M], ne = <span class="keyword">new</span> <span class="title class_">int</span>[M], color = <span class="keyword">new</span> <span class="title class_">int</span>[N];</span><br><span class="line">    <span class="type">int</span> idx;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        e[idx] = b;</span><br><span class="line">        ne[idx] = he[a];</span><br><span class="line">        he[a] = idx++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> cur)</span> &#123;</span><br><span class="line">        color[u] = cur;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> he[u]; i != -<span class="number">1</span>; i = ne[i]) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> e[i];</span><br><span class="line">            <span class="keyword">if</span> (color[j] == cur) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (color[j] == <span class="number">0</span> &amp;&amp; !dfs(j, <span class="number">3</span> - cur)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">possibleBipartition</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[][] ds)</span> &#123;</span><br><span class="line">        Arrays.fill(he, -<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//添加图</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] info : ds) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> info[<span class="number">0</span>], b = info[<span class="number">1</span>];</span><br><span class="line">            add(a, b); add(b, a);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//开始遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (color[i] != <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (!dfs(i, <span class="number">1</span>)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      
        <categories>
            
            <category> 算法集锦 </category>
            
            <category> 算法模板 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 模板 </tag>
            
            <tag> 前向星链图 </tag>
            
            <tag> 邻接表 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[整理生活和整理思维]]></title>
      <url>/2022/10/15/NO-3/</url>
      <content type="html"><![CDATA[<h2 id="整理生活和整理思维"><a href="#整理生活和整理思维" class="headerlink" title="整理生活和整理思维"></a>整理生活和整理思维</h2>]]></content>
      
        <categories>
            
            <category> 生活感悟 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 学习 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[序列dp之940 不同的子序列II]]></title>
      <url>/2022/10/09/NO.1/</url>
      <content type="html"><![CDATA[<h2 id="940、不同的子序列II"><a href="#940、不同的子序列II" class="headerlink" title="940、不同的子序列II"></a><a href="https://leetcode.cn/problems/distinct-subsequences-ii/">940、不同的子序列II</a></h2><h4 id="题目表述"><a href="#题目表述" class="headerlink" title="题目表述"></a>题目表述</h4><blockquote>
<p>给定一个字符串 s，计算 s 的 不同非空子序列 的个数。因为结果可能很大，所以返回答案需要对 10^9 + 7 取余 。</p>
<p>字符串的 子序列 是经由原字符串删除一些（也可能不删除）字符但不改变剩余字符相对位置的一个新字符串。</p>
<p>例如，”ace” 是 “abcde” 的一个子序列，但 “aec” 不是。</p>
<blockquote>
<p>示例 1：<br>输入：s = “abc”<br>输出：7<br>解释：7 个不同的子序列分别是 “a”, “b”, “c”, “ab”, “ac”, “bc”, 以及 “abc”。</p>
</blockquote>
<blockquote>
<p>示例 2：<br>输入：s = “aba”<br>输出：6<br>解释：6 个不同的子序列分别是 “a”, “b”, “ab”, “ba”, “aa” 以及 “aba”。    </p>
</blockquote>
<blockquote>
<p>示例 3：<br>输入：s = “aaa”<br>输出：3<br>解释：3 个不同的子序列分别是 “a”, “aa” 以及 “aaa”。</p>
</blockquote>
<p>提示：</p>
<p>1 &lt;= s.length &lt;= 2000<br>s 仅由小写英文字母组成</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode.cn/problems/distinct-subsequences-ii">https://leetcode.cn/problems/distinct-subsequences-ii</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
</blockquote>
<h4 id="序列DP题解"><a href="#序列DP题解" class="headerlink" title="序列DP题解"></a>序列DP题解</h4><p>这道题是属于序列DP，子问题是以某一个dp[i][j],其中i表示前i个字符，以字母j为结尾的有效序列有多少。其中j表示a~z,定义有了，接下来就是状态转移方程：</p>
<p>在dp[i][a~z]的过程中</p>
<p>第一种情况：</p>
<p>​                     s[i]！=j,这表示s[i]将不会被选中，那表示dp[i][j]=dp[i-1][j],</p>
<p>第二种情况：</p>
<p>​                      s[i]==j,这表示s[i]会被选中作为结尾字符，那么dp[i-1][a~z]所有的序列后边加上s[i]都将会组成新                                序列，那表示dp[i][j]=dp[i-1][a-z]+1,后面的1，表示s[i]单独作为一个序列。</p>
<p>所以最终的结果就是s[s.length-1][a~z]。</p>
<p>按道理来讲，需要dp转移矩阵是s.length*26的，但是可以进行空间的压缩，dp[i]行用的是dp[i-1]行的信息和dp[i-1]行的总和，所以可以进行空间的压缩，压缩后代码如下（这道题还有一点要注意，那就是要MOD一下）。</p>
<h4 id="代码题解"><a href="#代码题解" class="headerlink" title="代码题解"></a>代码题解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MOD</span> <span class="operator">=</span> (<span class="type">int</span>)<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">distinctSubseqII</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;length;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">            <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> c-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> dp[idx];</span><br><span class="line">            dp[idx] = (<span class="number">1</span>+result)%MOD;</span><br><span class="line">            result=(result+dp[idx])%MOD;</span><br><span class="line">            result = (result-tmp+MOD)%MOD;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      
        <categories>
            
            <category> 算法集锦 </category>
            
            <category> 算法题 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 字符串 </tag>
            
            <tag> 困难难度 </tag>
            
            <tag> 序列DP </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[856.括号的分数]]></title>
      <url>/2022/10/09/NO2/</url>
      <content type="html"><![CDATA[<h2 id="856-括号的分数"><a href="#856-括号的分数" class="headerlink" title="856. 括号的分数"></a>856. 括号的分数</h2><h4 id="题目表述"><a href="#题目表述" class="headerlink" title="题目表述"></a>题目表述</h4><blockquote>
<p>给定一个平衡括号字符串 S，按下述规则计算该字符串的分数：<br>() 得 1 分。<br>AB 得 A + B 分，其中 A 和 B 是平衡括号字符串。<br>(A) 得 2 * A 分，其中 A 是平衡括号字符串。</p>
</blockquote>
<p>示例 1<br>输入： “()”<br>输出： 1</p>
<p>示例 2：<br>输入： “(())”<br>输出： 2</p>
<p>示例 3：<br>输入： “()()”<br>输出： 2</p>
<p>示例 4：<br>输入： “(()(()))”<br>输出： 6</p>
<p>提示：<br>S 是平衡括号字符串，且只含有 ( 和 ) 。<br>2 &lt;= S.length &lt;= 50</p>
<h4 id="代码题解"><a href="#代码题解" class="headerlink" title="代码题解"></a>代码题解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    String s;</span><br><span class="line">    <span class="type">int</span> idx ;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">scoreOfParentheses</span><span class="params">(String s)</span> &#123;</span><br><span class="line">      <span class="comment">//使用递归函数，按照常规思维</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        idx = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">this</span>.s =s;</span><br><span class="line">        <span class="type">int</span> <span class="variable">lenth</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="keyword">while</span>(idx&lt;lenth)</span><br><span class="line">        &#123;</span><br><span class="line">            ans+=addWho();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//flag =0表示× flag = 1表示+</span></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">addWho</span><span class="params">()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span><span class="number">1</span>;</span><br><span class="line">       Deque&lt;Character&gt; deque  = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">       deque.push(s.charAt(idx));</span><br><span class="line">       idx++;</span><br><span class="line">       <span class="type">boolean</span> <span class="variable">on</span> <span class="operator">=</span><span class="literal">false</span>;</span><br><span class="line">       <span class="keyword">while</span>(!deque.isEmpty())</span><br><span class="line">       &#123;</span><br><span class="line">          <span class="comment">// System.out.println(idx);</span></span><br><span class="line">           <span class="type">char</span> <span class="variable">c</span>  <span class="operator">=</span>s.charAt(idx);</span><br><span class="line">           <span class="keyword">if</span>(!on)</span><br><span class="line">           &#123;</span><br><span class="line">               <span class="keyword">if</span>(c==<span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">               &#123;</span><br><span class="line">                   deque.push(c);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">else</span></span><br><span class="line">               &#123;</span><br><span class="line">                   on =<span class="literal">true</span>;</span><br><span class="line">                   deque.poll();</span><br><span class="line">               &#125;</span><br><span class="line">               idx++;</span><br><span class="line">           &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               <span class="keyword">if</span>(c==<span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">               &#123;</span><br><span class="line">                   ans+=addWho();</span><br><span class="line"></span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">else</span>&#123;</span><br><span class="line">                   deque.poll();</span><br><span class="line">                   ans=ans*<span class="number">2</span>;</span><br><span class="line">                   idx++;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      
        <categories>
            
            <category> 算法集锦 </category>
            
            <category> 算法题 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 字符串 </tag>
            
            <tag> 中等难度 </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
